<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tetris</title>
    <link rel="icon" href="logo.png" type="image/png" />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        background: #0a0a0a;
        color: #fff;
        font-family: "Segoe UI", system-ui, sans-serif;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        overflow: hidden;
      }

      .game-container {
        display: flex;
        gap: 24px;
        align-items: flex-start;
      }

      .side-panel {
        display: flex;
        flex-direction: column;
        gap: 16px;
        min-width: 175px;
      }

      .panel-box {
        background: #1a1a2e;
        border: 2px solid #333;
        border-radius: 8px;
        padding: 12px;
      }

      .panel-box h3 {
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 2px;
        color: #888;
        margin-bottom: 8px;
        text-align: center;
      }

      .panel-box .value {
        font-size: 22px;
        font-weight: bold;
        text-align: center;
        color: #fff;
      }

      #next-canvas {
        display: block;
        margin: 0 auto;
      }

      .board-wrapper {
        background: #1a1a2e;
        border: 3px solid #444;
        border-radius: 8px;
        padding: 4px;
        box-shadow: 0 0 40px rgba(100, 100, 255, 0.15);
      }

      #board {
        display: block;
      }

      .controls-info {
        font-size: 11px;
        color: #666;
        line-height: 1.8;
      }

      .controls-info kbd {
        background: #2a2a3e;
        border: 1px solid #444;
        border-radius: 3px;
        padding: 1px 6px;
        font-family: inherit;
        color: #aaa;
      }

      .overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.75);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10;
      }

      .overlay.hidden {
        display: none;
      }

      .overlay-content {
        text-align: center;
      }

      .overlay-content h1 {
        font-size: 48px;
        margin-bottom: 8px;
      }

      .overlay-content h2 {
        font-size: 32px;
        margin-bottom: 12px;
        color: #f44;
      }

      .overlay-content p {
        font-size: 18px;
        color: #aaa;
        margin-bottom: 4px;
      }

      .overlay-content .final-score {
        font-size: 24px;
        color: #fff;
        margin-bottom: 16px;
      }

      .overlay-content .prompt {
        font-size: 16px;
        color: #888;
        animation: blink 1.2s infinite;
      }

      @keyframes blink {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.3;
        }
      }

      .flash-row {
        animation: flash 0.15s ease-in-out;
      }

      @keyframes flash {
        0% {
          opacity: 1;
        }
        50% {
          opacity: 0;
        }
        100% {
          opacity: 1;
        }
      }

      .menu-buttons {
        display: flex;
        flex-direction: column;
        gap: 10px;
        margin-top: 20px;
        align-items: center;
      }

      .menu-btn {
        background: #2a2a4e;
        color: #fff;
        border: 2px solid #555;
        border-radius: 6px;
        padding: 10px 32px;
        font-size: 16px;
        font-family: inherit;
        cursor: pointer;
        width: 180px;
        transition:
          background 0.15s,
          border-color 0.15s;
      }

      .menu-btn:hover,
      .menu-btn:focus {
        background: #3a3a6e;
        border-color: #88f;
        outline: none;
      }

      .mute-btn {
        width: 100%;
        background: #2a2a4e;
        color: #fff;
        border: 2px solid #555;
        border-radius: 6px;
        padding: 10px;
        font-size: 14px;
        font-family: inherit;
        cursor: pointer;
        transition:
          background 0.15s,
          border-color 0.15s;
      }

      .mute-btn:hover,
      .mute-btn:focus {
        background: #3a3a6e;
        outline: none;
      }
    </style>
  </head>
  <body>
    <audio id="background-audio" loop>
      <source src="NmCCQxVBfyM.mp3" type="audio/mpeg" />
    </audio>
    <div class="game-container">
      <!-- Left panel -->
      <div class="side-panel">
        <div class="panel-box">
          <h3>Score</h3>
          <div class="value" id="score">0</div>
        </div>
        <div class="panel-box">
          <h3>Level</h3>
          <div class="value" id="level">1</div>
        </div>
        <div class="panel-box">
          <h3>Speed</h3>
          <div class="value" id="speed-display">800</div>
        </div>
        <div class="panel-box">
          <h3>Lines</h3>
          <div class="value" id="lines">0</div>
        </div>
        <div class="panel-box">
          <h3>Best</h3>
          <div class="value" id="high-score">0</div>
        </div>
        <div class="panel-box">
          <h3>Hold</h3>
          <canvas id="hold-canvas" width="112" height="60"></canvas>
        </div>
      </div>

      <!-- Board -->
      <div class="board-wrapper">
        <canvas id="board" width="300" height="600"></canvas>
      </div>

      <!-- Right panel -->
      <div class="side-panel">
        <div class="panel-box">
          <h3>Next</h3>
          <canvas id="next-canvas" width="112" height="60"></canvas>
        </div>
        <div class="panel-box controls-info">
          <h3>Controls</h3>
          <kbd>&larr;</kbd> <kbd>&rarr;</kbd> Move<br />
          <kbd>&darr;</kbd> Soft drop<br />
          <kbd>Space</kbd> Hard drop<br />
          <kbd>&uarr;</kbd> / <kbd>X</kbd> Rotate CW<br />
          <kbd>Z</kbd> Rotate CCW<br />
          <kbd>C</kbd> Hold<br />
          <kbd>M</kbd> Mute/Unmute<br />
          <kbd>Esc</kbd> / <kbd>P</kbd> Pause
        </div>
        <button class="mute-btn" id="mute-btn">ðŸ”Š Unmute</button>
      </div>
    </div>

    <!-- Start overlay -->
    <div class="overlay" id="start-overlay">
      <div class="overlay-content">
        <h1>TETRIS</h1>
        <p class="prompt">Press any key to start</p>
      </div>
    </div>

    <!-- Pause overlay -->
    <div class="overlay hidden" id="pause-overlay">
      <div class="overlay-content">
        <h2>PAUSED</h2>
        <div class="menu-buttons">
          <button class="menu-btn" id="btn-resume">Resume</button>
          <button class="menu-btn" id="btn-restart">Restart</button>
          <button class="menu-btn" id="btn-quit">Quit</button>
        </div>
      </div>
    </div>

    <!-- Game over overlay -->
    <div class="overlay hidden" id="gameover-overlay">
      <div class="overlay-content">
        <h2>GAME OVER</h2>
        <p class="final-score" id="final-score"></p>
        <p
          class="final-score"
          id="final-best"
          style="color: #aaa; font-size: 18px"
        ></p>
        <p
          id="new-best"
          style="
            color: #f0c000;
            font-size: 20px;
            font-weight: bold;
            display: none;
          "
        >
          NEW HIGH SCORE!
        </p>
        <p class="prompt">Press any key to restart &middot; Esc to quit</p>
      </div>
    </div>

    <script>
      (() => {
        // â”€â”€â”€ Audio Setup â”€â”€â”€
        const audioEl = document.getElementById("background-audio");
        const muteBtn = document.getElementById("mute-btn");
        let audioStarted = false;
        let muted = localStorage.getItem("tetris-muted") === "true";

        function applyMute() {
          audioEl.muted = muted;
          audioEl.volume = muted ? 0 : 1;
          muteBtn.textContent = muted ? "ðŸ”‡ Muted" : "ðŸ”Š Unmute";
          if (muted) {
            muteBtn.classList.add("muted");
          } else {
            muteBtn.classList.remove("muted");
          }
        }

        function startAudio() {
          if (!audioStarted) {
            applyMute();
            audioEl
              .play()
              .then(() => {
                audioStarted = true;
                applyMute();
              })
              .catch(() => {});
          }
        }

        function toggleMute() {
          muted = !muted;
          localStorage.setItem("tetris-muted", muted ? "true" : "false");
          applyMute();
          startAudio();
        }

        muteBtn.addEventListener("click", toggleMute);
        applyMute();

        // â”€â”€â”€ Constants â”€â”€â”€
        const COLS = 10;
        const ROWS = 20;
        const BLOCK = 30;
        const EMPTY = 0;

        const COLORS = {
          1: "#00f0f0", // I - cyan
          2: "#f0f000", // O - yellow
          3: "#a000f0", // T - purple
          4: "#00f000", // S - green
          5: "#f00000", // Z - red
          6: "#3366ff", // J - blue
          7: "#f0a000", // L - orange
        };

        const GHOST_ALPHA = 0.25;

        // Tetromino shapes (each rotation state)
        const SHAPES = {
          I: [
            [
              [0, 0, 0, 0],
              [1, 1, 1, 1],
              [0, 0, 0, 0],
              [0, 0, 0, 0],
            ],
            [
              [0, 0, 1, 0],
              [0, 0, 1, 0],
              [0, 0, 1, 0],
              [0, 0, 1, 0],
            ],
            [
              [0, 0, 0, 0],
              [0, 0, 0, 0],
              [1, 1, 1, 1],
              [0, 0, 0, 0],
            ],
            [
              [0, 1, 0, 0],
              [0, 1, 0, 0],
              [0, 1, 0, 0],
              [0, 1, 0, 0],
            ],
          ],
          O: [
            [
              [2, 2],
              [2, 2],
            ],
            [
              [2, 2],
              [2, 2],
            ],
            [
              [2, 2],
              [2, 2],
            ],
            [
              [2, 2],
              [2, 2],
            ],
          ],
          T: [
            [
              [0, 3, 0],
              [3, 3, 3],
              [0, 0, 0],
            ],
            [
              [0, 3, 0],
              [0, 3, 3],
              [0, 3, 0],
            ],
            [
              [0, 0, 0],
              [3, 3, 3],
              [0, 3, 0],
            ],
            [
              [0, 3, 0],
              [3, 3, 0],
              [0, 3, 0],
            ],
          ],
          S: [
            [
              [0, 4, 4],
              [4, 4, 0],
              [0, 0, 0],
            ],
            [
              [0, 4, 0],
              [0, 4, 4],
              [0, 0, 4],
            ],
            [
              [0, 0, 0],
              [0, 4, 4],
              [4, 4, 0],
            ],
            [
              [4, 0, 0],
              [4, 4, 0],
              [0, 4, 0],
            ],
          ],
          Z: [
            [
              [5, 5, 0],
              [0, 5, 5],
              [0, 0, 0],
            ],
            [
              [0, 0, 5],
              [0, 5, 5],
              [0, 5, 0],
            ],
            [
              [0, 0, 0],
              [5, 5, 0],
              [0, 5, 5],
            ],
            [
              [0, 5, 0],
              [5, 5, 0],
              [5, 0, 0],
            ],
          ],
          J: [
            [
              [6, 0, 0],
              [6, 6, 6],
              [0, 0, 0],
            ],
            [
              [0, 6, 6],
              [0, 6, 0],
              [0, 6, 0],
            ],
            [
              [0, 0, 0],
              [6, 6, 6],
              [0, 0, 6],
            ],
            [
              [0, 6, 0],
              [0, 6, 0],
              [6, 6, 0],
            ],
          ],
          L: [
            [
              [0, 0, 7],
              [7, 7, 7],
              [0, 0, 0],
            ],
            [
              [0, 7, 0],
              [0, 7, 0],
              [0, 7, 7],
            ],
            [
              [0, 0, 0],
              [7, 7, 7],
              [7, 0, 0],
            ],
            [
              [7, 7, 0],
              [0, 7, 0],
              [0, 7, 0],
            ],
          ],
        };

        // SRS wall kick data
        const KICK_JLSTZ = [
          [
            [0, 0],
            [-1, 0],
            [-1, 1],
            [0, -2],
            [-1, -2],
          ], // 0->1
          [
            [0, 0],
            [1, 0],
            [1, -1],
            [0, 2],
            [1, 2],
          ], // 1->2
          [
            [0, 0],
            [1, 0],
            [1, 1],
            [0, -2],
            [1, -2],
          ], // 2->3
          [
            [0, 0],
            [-1, 0],
            [-1, -1],
            [0, 2],
            [-1, 2],
          ], // 3->0
        ];
        const KICK_JLSTZ_CCW = [
          [
            [0, 0],
            [1, 0],
            [1, 1],
            [0, -2],
            [1, -2],
          ], // 0->3
          [
            [0, 0],
            [1, 0],
            [1, -1],
            [0, 2],
            [1, 2],
          ], // 1->0
          [
            [0, 0],
            [-1, 0],
            [-1, 1],
            [0, -2],
            [-1, -2],
          ], // 2->1
          [
            [0, 0],
            [-1, 0],
            [-1, -1],
            [0, 2],
            [-1, 2],
          ], // 3->2
        ];
        const KICK_I = [
          [
            [0, 0],
            [-2, 0],
            [1, 0],
            [-2, -1],
            [1, 2],
          ],
          [
            [0, 0],
            [-1, 0],
            [2, 0],
            [-1, 2],
            [2, -1],
          ],
          [
            [0, 0],
            [2, 0],
            [-1, 0],
            [2, 1],
            [-1, -2],
          ],
          [
            [0, 0],
            [1, 0],
            [-2, 0],
            [1, -2],
            [-2, 1],
          ],
        ];
        const KICK_I_CCW = [
          [
            [0, 0],
            [-1, 0],
            [2, 0],
            [-1, 2],
            [2, -1],
          ],
          [
            [0, 0],
            [2, 0],
            [-1, 0],
            [2, 1],
            [-1, -2],
          ],
          [
            [0, 0],
            [1, 0],
            [-2, 0],
            [1, -2],
            [-2, 1],
          ],
          [
            [0, 0],
            [-2, 0],
            [1, 0],
            [-2, -1],
            [1, 2],
          ],
        ];

        const PIECE_NAMES = ["I", "O", "T", "S", "Z", "J", "L"];
        const LINE_SCORES = [0, 100, 300, 500, 800];
        const SOFT_DROP_SCORE = 1;
        const HARD_DROP_SCORE = 2;

        // NES-inspired speed curve (ms per drop). Each level is noticeably faster.
        const LEVEL_SPEEDS = [
          800, // Level 1
          650, // Level 2
          500, // Level 3
          370, // Level 4
          280, // Level 5
          200, // Level 6
          150, // Level 7
          115, // Level 8
          85, // Level 9
          65, // Level 10
          50, // Level 11
          40, // Level 12
          33, // Level 13
          28, // Level 14
          23, // Level 15
          18, // Level 16+  "kill screen"
        ];

        function getSpeed(lvl) {
          const idx = Math.min(lvl - 1, LEVEL_SPEEDS.length - 1);
          return LEVEL_SPEEDS[idx];
        }

        function getLockDelay(lvl) {
          // Gentle lock delay scaling: 500ms at level 1, down to 350ms at level 15+
          return Math.max(350, 500 - (lvl - 1) * 10);
        }

        // â”€â”€â”€ DOM â”€â”€â”€
        const boardCanvas = document.getElementById("board");
        const ctx = boardCanvas.getContext("2d");
        const nextCanvas = document.getElementById("next-canvas");
        const nctx = nextCanvas.getContext("2d");
        const holdCanvas = document.getElementById("hold-canvas");
        const hctx = holdCanvas.getContext("2d");
        const scoreEl = document.getElementById("score");
        const levelEl = document.getElementById("level");
        const speedEl = document.getElementById("speed-display");
        const linesEl = document.getElementById("lines");
        const startOverlay = document.getElementById("start-overlay");
        const pauseOverlay = document.getElementById("pause-overlay");
        const gameoverOverlay = document.getElementById("gameover-overlay");
        const finalScoreEl = document.getElementById("final-score");
        const finalBestEl = document.getElementById("final-best");
        const newBestEl = document.getElementById("new-best");
        const highScoreEl = document.getElementById("high-score");

        let highScore =
          parseInt(localStorage.getItem("tetris-high-score")) || 0;
        highScoreEl.textContent = highScore;

        // â”€â”€â”€ Game state â”€â”€â”€
        let board, score, lines, level, gameOver, paused, started;
        let current, currentX, currentY, currentRotation, currentType;
        let nextType, holdType, holdUsed;
        let bag;
        let dropTimer, lastTime;
        let lockDelay, lockTimer, lockMoves;
        let animatingLines;
        let rafId;

        // â”€â”€â”€ Helpers â”€â”€â”€
        function createBoard() {
          return Array.from({ length: ROWS }, () =>
            new Array(COLS).fill(EMPTY),
          );
        }

        function getShape(type, rot) {
          return SHAPES[type][rot];
        }

        function shuffledBag() {
          const arr = [...PIECE_NAMES];
          for (let i = arr.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
          }
          return arr;
        }

        function nextPiece() {
          if (bag.length === 0) bag = shuffledBag();
          return bag.pop();
        }

        function collides(shape, bx, by) {
          for (let r = 0; r < shape.length; r++) {
            for (let c = 0; c < shape[r].length; c++) {
              if (shape[r][c] !== 0) {
                const nx = bx + c;
                const ny = by + r;
                if (nx < 0 || nx >= COLS || ny >= ROWS) return true;
                if (ny >= 0 && board[ny][nx] !== EMPTY) return true;
              }
            }
          }
          return false;
        }

        function lockPiece() {
          const shape = getShape(currentType, currentRotation);
          for (let r = 0; r < shape.length; r++) {
            for (let c = 0; c < shape[r].length; c++) {
              if (shape[r][c] !== 0) {
                const ny = currentY + r;
                const nx = currentX + c;
                if (ny < 0) {
                  triggerGameOver();
                  return;
                }
                board[ny][nx] = shape[r][c];
              }
            }
          }
          clearLines();
        }

        function clearLines() {
          const full = [];
          for (let r = 0; r < ROWS; r++) {
            if (board[r].every((c) => c !== EMPTY)) full.push(r);
          }
          if (full.length === 0) {
            holdUsed = false;
            spawn();
            return;
          }

          animatingLines = full;

          // Flash then remove, spawn AFTER clearing is done
          setTimeout(() => {
            // Remove lines first (must be descending to keep indices valid)
            full.sort((a, b) => b - a);
            for (const r of full) {
              board.splice(r, 1);
            }
            // Add new lines at the top
            for (let i = 0; i < full.length; i++) {
              board.unshift(new Array(COLS).fill(EMPTY));
            }

            const count = full.length;
            lines += count;
            score += LINE_SCORES[count] * level;
            level = Math.floor(lines / 10) + 1;
            updateUI();
            animatingLines = null;
            holdUsed = false;
            spawn();
          }, 200);
        }

        function spawn() {
          currentType = nextType;
          nextType = nextPiece();
          currentRotation = 0;
          current = getShape(currentType, 0);
          currentX = Math.floor((COLS - current[0].length) / 2);
          currentY = -1;
          lockTimer = 0;
          lockMoves = 0;
          dropTimer = 0;

          if (collides(current, currentX, currentY)) {
            triggerGameOver();
            return;
          }
          drawNext();
          drawHold();
        }

        function triggerGameOver() {
          gameOver = true;
          cancelAnimationFrame(rafId);
          const isNewBest = score > 0 && score >= highScore;
          if (score > highScore) {
            highScore = score;
            highScoreEl.textContent = highScore;
          }
          localStorage.setItem("tetris-high-score", highScore);
          finalScoreEl.textContent = `Score: ${score}`;
          finalBestEl.textContent = `Best: ${highScore}`;
          newBestEl.style.display = isNewBest ? "block" : "none";
          gameoverOverlay.classList.remove("hidden");
          applyMute();
        }

        function ghostY() {
          const shape = getShape(currentType, currentRotation);
          let gy = currentY;
          while (!collides(shape, currentX, gy + 1)) gy++;
          return gy;
        }

        // â”€â”€â”€ Movement â”€â”€â”€
        function moveLeft() {
          const shape = getShape(currentType, currentRotation);
          if (!collides(shape, currentX - 1, currentY)) {
            currentX--;
            resetLock();
            return true;
          }
          return false;
        }

        function moveRight() {
          const shape = getShape(currentType, currentRotation);
          if (!collides(shape, currentX + 1, currentY)) {
            currentX++;
            resetLock();
            return true;
          }
          return false;
        }

        function moveDown() {
          const shape = getShape(currentType, currentRotation);
          if (!collides(shape, currentX, currentY + 1)) {
            currentY++;
            return true;
          }
          return false;
        }

        function hardDrop() {
          const shape = getShape(currentType, currentRotation);
          let dropped = 0;
          while (!collides(shape, currentX, currentY + 1)) {
            currentY++;
            dropped++;
          }
          score += dropped * HARD_DROP_SCORE;
          updateUI();
          lockPiece();
        }

        function rotate(dir) {
          const newRot = (currentRotation + dir + 4) % 4;
          const shape = getShape(currentType, newRot);

          let kicks;
          if (currentType === "I") {
            kicks =
              dir === 1 ? KICK_I[currentRotation] : KICK_I_CCW[currentRotation];
          } else if (currentType === "O") {
            kicks = [[0, 0]];
          } else {
            kicks =
              dir === 1
                ? KICK_JLSTZ[currentRotation]
                : KICK_JLSTZ_CCW[currentRotation];
          }

          for (const [kx, ky] of kicks) {
            if (!collides(shape, currentX + kx, currentY - ky)) {
              currentX += kx;
              currentY -= ky;
              currentRotation = newRot;
              current = shape;
              resetLock();
              return true;
            }
          }
          return false;
        }

        function holdPiece() {
          if (holdUsed) return;
          holdUsed = true;
          if (holdType === null) {
            holdType = currentType;
            spawn();
          } else {
            const tmp = holdType;
            holdType = currentType;
            currentType = tmp;
            currentRotation = 0;
            current = getShape(currentType, 0);
            currentX = Math.floor((COLS - current[0].length) / 2);
            currentY = -1;
            lockTimer = 0;
            lockMoves = 0;
          }
          drawHold();
        }

        function resetLock() {
          if (lockMoves < 15) {
            lockTimer = 0;
            lockMoves++;
          }
        }

        // â”€â”€â”€ Drawing â”€â”€â”€
        function drawBlock(context, x, y, colorId, alpha = 1) {
          const color = COLORS[colorId];
          context.globalAlpha = alpha;
          context.fillStyle = color;
          context.fillRect(x * BLOCK, y * BLOCK, BLOCK, BLOCK);

          // Highlight
          context.fillStyle = "rgba(255,255,255,0.2)";
          context.fillRect(x * BLOCK, y * BLOCK, BLOCK, 2);
          context.fillRect(x * BLOCK, y * BLOCK, 2, BLOCK);

          // Shadow
          context.fillStyle = "rgba(0,0,0,0.25)";
          context.fillRect(x * BLOCK + BLOCK - 2, y * BLOCK, 2, BLOCK);
          context.fillRect(x * BLOCK, y * BLOCK + BLOCK - 2, BLOCK, 2);

          // Border
          context.strokeStyle = "rgba(0,0,0,0.4)";
          context.lineWidth = 1;
          context.strokeRect(
            x * BLOCK + 0.5,
            y * BLOCK + 0.5,
            BLOCK - 1,
            BLOCK - 1,
          );

          context.globalAlpha = 1;
        }

        function drawBoard() {
          ctx.fillStyle = "#111122";
          ctx.fillRect(0, 0, boardCanvas.width, boardCanvas.height);

          // Grid lines
          ctx.strokeStyle = "rgba(255,255,255,0.03)";
          ctx.lineWidth = 1;
          for (let r = 0; r <= ROWS; r++) {
            ctx.beginPath();
            ctx.moveTo(0, r * BLOCK);
            ctx.lineTo(COLS * BLOCK, r * BLOCK);
            ctx.stroke();
          }
          for (let c = 0; c <= COLS; c++) {
            ctx.beginPath();
            ctx.moveTo(c * BLOCK, 0);
            ctx.lineTo(c * BLOCK, ROWS * BLOCK);
            ctx.stroke();
          }

          // Locked pieces
          for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
              if (board[r][c] !== EMPTY) {
                const flash = animatingLines && animatingLines.includes(r);
                if (flash) {
                  ctx.fillStyle = "#fff";
                  ctx.fillRect(c * BLOCK, r * BLOCK, BLOCK, BLOCK);
                } else {
                  drawBlock(ctx, c, r, board[r][c]);
                }
              }
            }
          }

          if (gameOver || !currentType) return;

          // Ghost piece
          const gy = ghostY();
          const shape = getShape(currentType, currentRotation);
          for (let r = 0; r < shape.length; r++) {
            for (let c = 0; c < shape[r].length; c++) {
              if (shape[r][c] !== 0) {
                const py = gy + r;
                if (py >= 0)
                  drawBlock(ctx, currentX + c, py, shape[r][c], GHOST_ALPHA);
              }
            }
          }

          // Current piece
          for (let r = 0; r < shape.length; r++) {
            for (let c = 0; c < shape[r].length; c++) {
              if (shape[r][c] !== 0) {
                const py = currentY + r;
                if (py >= 0) drawBlock(ctx, currentX + c, py, shape[r][c]);
              }
            }
          }
        }

        function drawPreview(context, canvas, type) {
          context.fillStyle = "#1a1a2e";
          context.fillRect(0, 0, canvas.width, canvas.height);
          if (!type) return;

          const shape = getShape(type, 0);
          const rows = shape.length;
          const cols = shape[0].length;
          const previewBlock = 20;
          const ox = Math.floor((canvas.width - cols * previewBlock) / 2);
          const oy = Math.floor((canvas.height - rows * previewBlock) / 2);

          for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
              if (shape[r][c] !== 0) {
                const color = COLORS[shape[r][c]];
                context.fillStyle = color;
                context.fillRect(
                  ox + c * previewBlock,
                  oy + r * previewBlock,
                  previewBlock,
                  previewBlock,
                );
                context.strokeStyle = "rgba(0,0,0,0.4)";
                context.lineWidth = 1;
                context.strokeRect(
                  ox + c * previewBlock + 0.5,
                  oy + r * previewBlock + 0.5,
                  previewBlock - 1,
                  previewBlock - 1,
                );
                context.fillStyle = "rgba(255,255,255,0.15)";
                context.fillRect(
                  ox + c * previewBlock,
                  oy + r * previewBlock,
                  previewBlock,
                  2,
                );
                context.fillRect(
                  ox + c * previewBlock,
                  oy + r * previewBlock,
                  2,
                  previewBlock,
                );
              }
            }
          }
        }

        function drawNext() {
          drawPreview(nctx, nextCanvas, nextType);
        }

        function drawHold() {
          drawPreview(hctx, holdCanvas, holdType);
        }

        function updateUI() {
          scoreEl.textContent = score;
          levelEl.textContent = level;
          speedEl.textContent = getSpeed(level);
          linesEl.textContent = lines;
          if (score > highScore) {
            highScore = score;
            highScoreEl.textContent = highScore;
          }
        }

        // â”€â”€â”€ DAS / Auto-repeat â”€â”€â”€
        const DAS_DELAY = 170;
        const DAS_REPEAT = 50;
        let keys = {};
        let dasTimer = {};
        let dasActive = {};

        function startDAS(key, action) {
          if (dasActive[key]) return;
          action();
          dasActive[key] = true;
          dasTimer[key] = setTimeout(() => {
            dasTimer[key] = setInterval(() => {
              if (!paused && !gameOver && started) action();
            }, DAS_REPEAT);
          }, DAS_DELAY);
        }

        function stopDAS(key) {
          clearTimeout(dasTimer[key]);
          clearInterval(dasTimer[key]);
          dasActive[key] = false;
        }

        // â”€â”€â”€ Input â”€â”€â”€
        document.addEventListener("keydown", (e) => {
          // Allow mute toggle in any state
          if (e.code === "KeyM") {
            e.preventDefault();
            toggleMute();
            return;
          }

          if (!started) {
            startGame();
            return;
          }

          if (gameOver) {
            if (e.code === "Escape") {
              quitToTitle();
            } else if (e.code !== "KeyP") {
              gameoverOverlay.classList.add("hidden");
              startGame();
            }
            return;
          }

          if (e.code === "KeyP" || e.code === "Escape") {
            togglePause();
            return;
          }

          if (paused || animatingLines) return;

          switch (e.code) {
            case "ArrowLeft":
              e.preventDefault();
              startDAS("left", moveLeft);
              break;
            case "ArrowRight":
              e.preventDefault();
              startDAS("right", moveRight);
              break;
            case "ArrowDown":
              e.preventDefault();
              if (!keys["down"]) {
                keys["down"] = true;
              }
              break;
            case "ArrowUp":
            case "KeyX":
              e.preventDefault();
              rotate(1);
              break;
            case "KeyZ":
              e.preventDefault();
              rotate(-1);
              break;
            case "Space":
              e.preventDefault();
              hardDrop();
              break;
            case "KeyC":
            case "ShiftLeft":
            case "ShiftRight":
              e.preventDefault();
              holdPiece();
              break;
          }
        });

        document.addEventListener("keyup", (e) => {
          switch (e.code) {
            case "ArrowLeft":
              stopDAS("left");
              break;
            case "ArrowRight":
              stopDAS("right");
              break;
            case "ArrowDown":
              keys["down"] = false;
              break;
          }
        });

        function togglePause() {
          paused = !paused;
          if (paused) {
            pauseOverlay.classList.remove("hidden");
          } else {
            pauseOverlay.classList.add("hidden");
            lastTime = performance.now();
          }
        }

        function resumeGame() {
          if (!paused) return;
          paused = false;
          pauseOverlay.classList.add("hidden");
          lastTime = performance.now();
        }

        function quitToTitle() {
          paused = false;
          gameOver = false;
          started = false;
          cancelAnimationFrame(rafId);
          pauseOverlay.classList.add("hidden");
          gameoverOverlay.classList.add("hidden");
          startOverlay.classList.remove("hidden");
          ctx.fillStyle = "#111122";
          ctx.fillRect(0, 0, boardCanvas.width, boardCanvas.height);
          drawPreview(nctx, nextCanvas, null);
          drawPreview(hctx, holdCanvas, null);
          scoreEl.textContent = "0";
          levelEl.textContent = "1";
          linesEl.textContent = "0";
          applyMute();
        }

        // Pause menu buttons
        document
          .getElementById("btn-resume")
          .addEventListener("click", resumeGame);
        document.getElementById("btn-restart").addEventListener("click", () => {
          pauseOverlay.classList.add("hidden");
          paused = false;
          startGame();
        });
        document
          .getElementById("btn-quit")
          .addEventListener("click", quitToTitle);

        // â”€â”€â”€ Game loop â”€â”€â”€
        function gameLoop(time) {
          rafId = requestAnimationFrame(gameLoop);

          if (paused || gameOver || animatingLines) {
            lastTime = time;
            drawBoard();
            return;
          }

          const delta = time - lastTime;
          lastTime = time;

          dropTimer += delta;

          // Check if piece is on ground
          const shape = getShape(currentType, currentRotation);
          let onGround = collides(shape, currentX, currentY + 1);

          // Lock delay scaled by level
          const lockDelay = getLockDelay(level);
          if (onGround) {
            lockTimer += delta;
            if (lockTimer >= lockDelay) {
              lockPiece();
              dropTimer = 0;
            }
          } else {
            lockTimer = 0;
          }

          const dropInterval = keys["down"] ? 50 : getSpeed(level);

          // Gravity catch-up: move multiple rows if needed for consistent drop speed
          while (dropTimer >= dropInterval && !onGround) {
            dropTimer -= dropInterval;

            // Recompute onGround since state changes as we move
            const shape2 = getShape(currentType, currentRotation);
            onGround = collides(shape2, currentX, currentY + 1);
            if (onGround) break;

            if (moveDown()) {
              if (keys["down"]) {
                score += SOFT_DROP_SCORE;
                updateUI();
              }
            } else {
              break;
            }
          }

          drawBoard();
        }

        // â”€â”€â”€ Init â”€â”€â”€
        function startGame() {
          board = createBoard();
          score = 0;
          lines = 0;
          level = 1;
          gameOver = false;
          paused = false;
          started = true;
          holdType = null;
          holdUsed = false;
          bag = shuffledBag();
          nextType = nextPiece();
          dropTimer = 0;
          lockTimer = 0;
          lockMoves = 0;
          animatingLines = null;
          lastTime = performance.now();

          startOverlay.classList.add("hidden");
          gameoverOverlay.classList.add("hidden");
          pauseOverlay.classList.add("hidden");

          applyMute();
          startAudio();
          updateUI();
          spawn();

          cancelAnimationFrame(rafId);
          rafId = requestAnimationFrame(gameLoop);
        }

        // Initial draw
        ctx.fillStyle = "#111122";
        ctx.fillRect(0, 0, boardCanvas.width, boardCanvas.height);
        drawPreview(nctx, nextCanvas, null);
        drawPreview(hctx, holdCanvas, null);
      })();
    </script>
  </body>
</html>
