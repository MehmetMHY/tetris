<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tetris</title>
    <link rel="icon" href="logo.png" type="image/png" />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        background: #0a0a0a;
        color: #fff;
        font-family: "Segoe UI", system-ui, sans-serif;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        overflow: hidden;
      }

      * {
        font-family: inherit;
      }

      .game-container {
        display: flex;
        gap: 24px;
        align-items: flex-start;
      }

      .side-panel {
        display: flex;
        flex-direction: column;
        gap: 16px;
        min-width: 175px;
      }

      .panel-box {
        background: #1a1a2e;
        border: 2px solid #333;
        border-radius: 8px;
        padding: 12px;
      }

      .panel-box h3 {
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 2px;
        color: #888;
        margin-bottom: 8px;
        text-align: center;
      }

      .panel-box .value {
        font-size: 22px;
        font-weight: bold;
        text-align: center;
        color: #fff;
      }

      #next-canvas {
        display: block;
        margin: 0 auto;
      }

      .board-wrapper {
        background: #1a1a2e;
        border: 3px solid #444;
        border-radius: 8px;
        padding: 4px;
        box-shadow: 0 0 40px rgba(100, 100, 255, 0.15);
      }

      #board {
        display: block;
      }

      .controls-info {
        font-size: 11px;
        color: #666;
        line-height: 1.8;
      }

      .controls-info kbd {
        background: #2a2a3e;
        border: 1px solid #444;
        border-radius: 3px;
        padding: 1px 6px;
        font-family: inherit;
        color: #aaa;
      }

      .overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.75);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10;
      }

      .overlay.hidden {
        display: none;
      }

      .overlay-content {
        text-align: center;
      }

      .overlay-content h1 {
        font-size: 48px;
        margin-bottom: 8px;
      }

      .overlay-content h2 {
        font-size: 32px;
        margin-bottom: 12px;
        color: #f44;
      }

      .overlay-content p {
        font-size: 18px;
        color: #aaa;
        margin-bottom: 4px;
      }

      .overlay-content .final-score {
        font-size: 24px;
        color: #fff;
        margin-bottom: 16px;
      }

      .overlay-content .prompt {
        font-size: 16px;
        color: #888;
        animation: blink 1.2s infinite;
      }

      @keyframes blink {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.3;
        }
      }

      .flash-row {
        animation: flash 0.15s ease-in-out;
      }

      @keyframes flash {
        0% {
          opacity: 1;
        }
        50% {
          opacity: 0;
        }
        100% {
          opacity: 1;
        }
      }

      .menu-buttons {
        display: flex;
        flex-direction: column;
        gap: 10px;
        margin-top: 20px;
        align-items: center;
      }

      .menu-btn {
        background: #2a2a4e;
        color: #fff;
        border: 2px solid #555;
        border-radius: 6px;
        padding: 10px 32px;
        font-size: 16px;
        font-family: inherit;
        cursor: pointer;
        width: 180px;
        transition:
          background 0.15s,
          border-color 0.15s;
      }

      .menu-btn:hover,
      .menu-btn:focus,
      .menu-btn.selected {
        background: #3a3a6e;
        border-color: #88f;
        outline: none;
      }

      .button-group {
        display: flex;
        gap: 8px;
      }

      .mute-btn,
      .settings-btn {
        flex: 1;
        background: #2a2a4e;
        color: #fff;
        border: 2px solid #555;
        border-radius: 6px;
        padding: 10px;
        font-size: 14px;
        font-family: inherit;
        cursor: pointer;
        transition:
          background 0.15s,
          border-color 0.15s;
      }

      .mute-btn:hover,
      .mute-btn:focus,
      .settings-btn:hover,
      .settings-btn:focus {
        background: #3a3a6e;
        outline: none;
      }
    </style>
  </head>
  <body>
    <audio id="background-audio" loop>
      <source src="NmCCQxVBfyM.mp3" type="audio/mpeg" />
    </audio>
    <div class="game-container">
      <!-- Left panel -->
      <div class="side-panel">
        <div class="panel-box">
          <h3>Score</h3>
          <div class="value" id="score">0</div>
        </div>
        <div class="panel-box">
          <h3>Level</h3>
          <div class="value" id="level">1</div>
        </div>
        <div class="panel-box">
          <h3>Speed</h3>
          <div class="value" id="speed-display">800</div>
        </div>
        <div class="panel-box">
          <h3>Lines</h3>
          <div class="value" id="lines">0</div>
        </div>
        <div class="panel-box">
          <h3>Best</h3>
          <div class="value" id="high-score">0</div>
        </div>
        <div class="panel-box">
          <h3>Hold</h3>
          <canvas id="hold-canvas" width="112" height="60"></canvas>
        </div>
      </div>

      <!-- Board -->
      <div class="board-wrapper">
        <canvas id="board" width="300" height="600"></canvas>
      </div>

      <!-- Right panel -->
      <div class="side-panel">
        <div class="panel-box">
          <h3>Next</h3>
          <canvas id="next-canvas" width="112" height="60"></canvas>
        </div>
        <div class="panel-box controls-info">
          <h3>Controls</h3>
          <kbd>&larr;</kbd><kbd>A</kbd> <kbd>&rarr;</kbd><kbd>D</kbd> Move<br />
          <kbd>&darr;</kbd><kbd>S</kbd> Soft drop<br />
          <kbd>Space</kbd> Hard drop<br />
          <kbd>&uarr;</kbd><kbd>W</kbd> / <kbd>X</kbd> Rotate CW<br />
          <kbd>Z</kbd> Rotate CCW<br />
          <kbd>C</kbd> Hold<br />
          <kbd>M</kbd> Mute/Unmute<br />
          <kbd>Esc</kbd> / <kbd>P</kbd> Pause
        </div>
        <div class="button-group">
          <button class="mute-btn" id="mute-btn">Mute</button>
          <button class="settings-btn" id="pause-btn">Pause</button>
        </div>
      </div>
    </div>

    <!-- Start overlay -->
    <div class="overlay" id="start-overlay">
      <div class="overlay-content">
        <h1>TETRIS</h1>
        <p class="prompt">Press any key to start</p>
      </div>
    </div>

    <!-- Pause overlay -->
    <div class="overlay hidden" id="pause-overlay">
      <div class="overlay-content">
        <h2>PAUSED</h2>
        <div class="menu-buttons">
          <button class="menu-btn" id="btn-resume">Resume</button>
          <button class="menu-btn" id="btn-restart">Restart</button>
          <button class="menu-btn" id="btn-quit">Quit</button>
        </div>
      </div>
    </div>

    <!-- Game over overlay -->
    <div class="overlay hidden" id="gameover-overlay">
      <div class="overlay-content">
        <h2>GAME OVER</h2>
        <p class="final-score" id="final-score"></p>
        <p
          class="final-score"
          id="final-best"
          style="color: #aaa; font-size: 18px"
        ></p>
        <p
          id="new-best"
          style="
            color: #f0c000;
            font-size: 20px;
            font-weight: bold;
            display: none;
          "
        >
          NEW HIGH SCORE!
        </p>
        <p class="prompt">Press any key to restart &middot; Esc to quit</p>
      </div>
    </div>

    <script>
      (() => {
        // ─── Audio Setup ───
        const audioEl = document.getElementById("background-audio");
        const muteBtn = document.getElementById("mute-btn");
        let audioStarted = false;
        let muted = localStorage.getItem("tetris-muted") === "true";

        function applyMute() {
          audioEl.muted = muted;
          audioEl.volume = muted ? 0 : 1;
          muteBtn.textContent = muted ? "Muted" : "Mute";
          if (muted) {
            muteBtn.classList.add("muted");
          } else {
            muteBtn.classList.remove("muted");
          }
        }

        function startAudio() {
          if (!audioStarted) {
            applyMute();
            audioEl
              .play()
              .then(() => {
                audioStarted = true;
                applyMute();
              })
              .catch(() => {});
          }
        }

        function toggleMute() {
          muted = !muted;
          localStorage.setItem("tetris-muted", muted ? "true" : "false");
          applyMute();
          startAudio();
        }

        muteBtn.addEventListener("click", () => {
          muteBtn.blur();
          toggleMute();
        });

        const pauseBtn = document.getElementById("pause-btn");
        pauseBtn.addEventListener("click", () => {
          pauseBtn.blur();
          if (started && !gameOver) togglePause();
        });

        applyMute();

        // ─── Constants ───
        const COLS = 10;
        const ROWS = 20;
        const BLOCK = 30;
        const EMPTY = 0;

        const COLORS = {
          1: "#00f0f0", // I - cyan
          2: "#f0f000", // O - yellow
          3: "#a000f0", // T - purple
          4: "#00f000", // S - green
          5: "#f00000", // Z - red
          6: "#3366ff", // J - blue
          7: "#f0a000", // L - orange
        };

        const GHOST_ALPHA = 0.25;
        const PREVIEW_BLOCK = 20;

        // ─── Pre-rendered block sprites (1 drawImage vs 6 draw calls per block) ───
        const blockSprites = {};
        const ghostSprites = {};
        const previewSprites = {};
        (function buildSprites() {
          function boardSprite(colorId, alpha) {
            const c = document.createElement("canvas");
            c.width = BLOCK;
            c.height = BLOCK;
            const x = c.getContext("2d");
            x.globalAlpha = alpha;
            x.fillStyle = COLORS[colorId];
            x.fillRect(0, 0, BLOCK, BLOCK);
            x.fillStyle = "rgba(255,255,255,0.2)";
            x.fillRect(0, 0, BLOCK, 2);
            x.fillRect(0, 0, 2, BLOCK);
            x.fillStyle = "rgba(0,0,0,0.25)";
            x.fillRect(BLOCK - 2, 0, 2, BLOCK);
            x.fillRect(0, BLOCK - 2, BLOCK, 2);
            x.strokeStyle = "rgba(0,0,0,0.4)";
            x.lineWidth = 1;
            x.strokeRect(0.5, 0.5, BLOCK - 1, BLOCK - 1);
            return c;
          }
          function prevSprite(colorId) {
            const s = PREVIEW_BLOCK;
            const c = document.createElement("canvas");
            c.width = s;
            c.height = s;
            const x = c.getContext("2d");
            x.fillStyle = COLORS[colorId];
            x.fillRect(0, 0, s, s);
            x.strokeStyle = "rgba(0,0,0,0.4)";
            x.lineWidth = 1;
            x.strokeRect(0.5, 0.5, s - 1, s - 1);
            x.fillStyle = "rgba(255,255,255,0.15)";
            x.fillRect(0, 0, s, 2);
            x.fillRect(0, 0, 2, s);
            return c;
          }
          for (let id = 1; id <= 7; id++) {
            blockSprites[id] = boardSprite(id, 1);
            ghostSprites[id] = boardSprite(id, GHOST_ALPHA);
            previewSprites[id] = prevSprite(id);
          }
        })();

        // ─── Pre-rendered background + grid (drawn once, blitted each frame) ───
        const bgCanvas = document.createElement("canvas");
        bgCanvas.width = COLS * BLOCK;
        bgCanvas.height = ROWS * BLOCK;
        (function buildBg() {
          const g = bgCanvas.getContext("2d");
          g.fillStyle = "#111122";
          g.fillRect(0, 0, bgCanvas.width, bgCanvas.height);
          g.strokeStyle = "rgba(255,255,255,0.03)";
          g.lineWidth = 1;
          for (let r = 0; r <= ROWS; r++) {
            g.beginPath();
            g.moveTo(0, r * BLOCK);
            g.lineTo(COLS * BLOCK, r * BLOCK);
            g.stroke();
          }
          for (let c = 0; c <= COLS; c++) {
            g.beginPath();
            g.moveTo(c * BLOCK, 0);
            g.lineTo(c * BLOCK, ROWS * BLOCK);
            g.stroke();
          }
        })();

        // Tetromino shapes (each rotation state)
        const SHAPES = {
          I: [
            [
              [0, 0, 0, 0],
              [1, 1, 1, 1],
              [0, 0, 0, 0],
              [0, 0, 0, 0],
            ],
            [
              [0, 0, 1, 0],
              [0, 0, 1, 0],
              [0, 0, 1, 0],
              [0, 0, 1, 0],
            ],
            [
              [0, 0, 0, 0],
              [0, 0, 0, 0],
              [1, 1, 1, 1],
              [0, 0, 0, 0],
            ],
            [
              [0, 1, 0, 0],
              [0, 1, 0, 0],
              [0, 1, 0, 0],
              [0, 1, 0, 0],
            ],
          ],
          O: [
            [
              [2, 2],
              [2, 2],
            ],
            [
              [2, 2],
              [2, 2],
            ],
            [
              [2, 2],
              [2, 2],
            ],
            [
              [2, 2],
              [2, 2],
            ],
          ],
          T: [
            [
              [0, 3, 0],
              [3, 3, 3],
              [0, 0, 0],
            ],
            [
              [0, 3, 0],
              [0, 3, 3],
              [0, 3, 0],
            ],
            [
              [0, 0, 0],
              [3, 3, 3],
              [0, 3, 0],
            ],
            [
              [0, 3, 0],
              [3, 3, 0],
              [0, 3, 0],
            ],
          ],
          S: [
            [
              [0, 4, 4],
              [4, 4, 0],
              [0, 0, 0],
            ],
            [
              [0, 4, 0],
              [0, 4, 4],
              [0, 0, 4],
            ],
            [
              [0, 0, 0],
              [0, 4, 4],
              [4, 4, 0],
            ],
            [
              [4, 0, 0],
              [4, 4, 0],
              [0, 4, 0],
            ],
          ],
          Z: [
            [
              [5, 5, 0],
              [0, 5, 5],
              [0, 0, 0],
            ],
            [
              [0, 0, 5],
              [0, 5, 5],
              [0, 5, 0],
            ],
            [
              [0, 0, 0],
              [5, 5, 0],
              [0, 5, 5],
            ],
            [
              [0, 5, 0],
              [5, 5, 0],
              [5, 0, 0],
            ],
          ],
          J: [
            [
              [6, 0, 0],
              [6, 6, 6],
              [0, 0, 0],
            ],
            [
              [0, 6, 6],
              [0, 6, 0],
              [0, 6, 0],
            ],
            [
              [0, 0, 0],
              [6, 6, 6],
              [0, 0, 6],
            ],
            [
              [0, 6, 0],
              [0, 6, 0],
              [6, 6, 0],
            ],
          ],
          L: [
            [
              [0, 0, 7],
              [7, 7, 7],
              [0, 0, 0],
            ],
            [
              [0, 7, 0],
              [0, 7, 0],
              [0, 7, 7],
            ],
            [
              [0, 0, 0],
              [7, 7, 7],
              [7, 0, 0],
            ],
            [
              [7, 7, 0],
              [0, 7, 0],
              [0, 7, 0],
            ],
          ],
        };

        // SRS wall kick data
        const KICK_JLSTZ = [
          [
            [0, 0],
            [-1, 0],
            [-1, 1],
            [0, -2],
            [-1, -2],
          ], // 0->1
          [
            [0, 0],
            [1, 0],
            [1, -1],
            [0, 2],
            [1, 2],
          ], // 1->2
          [
            [0, 0],
            [1, 0],
            [1, 1],
            [0, -2],
            [1, -2],
          ], // 2->3
          [
            [0, 0],
            [-1, 0],
            [-1, -1],
            [0, 2],
            [-1, 2],
          ], // 3->0
        ];
        const KICK_JLSTZ_CCW = [
          [
            [0, 0],
            [1, 0],
            [1, 1],
            [0, -2],
            [1, -2],
          ], // 0->3
          [
            [0, 0],
            [1, 0],
            [1, -1],
            [0, 2],
            [1, 2],
          ], // 1->0
          [
            [0, 0],
            [-1, 0],
            [-1, 1],
            [0, -2],
            [-1, -2],
          ], // 2->1
          [
            [0, 0],
            [-1, 0],
            [-1, -1],
            [0, 2],
            [-1, 2],
          ], // 3->2
        ];
        const KICK_I = [
          [
            [0, 0],
            [-2, 0],
            [1, 0],
            [-2, -1],
            [1, 2],
          ],
          [
            [0, 0],
            [-1, 0],
            [2, 0],
            [-1, 2],
            [2, -1],
          ],
          [
            [0, 0],
            [2, 0],
            [-1, 0],
            [2, 1],
            [-1, -2],
          ],
          [
            [0, 0],
            [1, 0],
            [-2, 0],
            [1, -2],
            [-2, 1],
          ],
        ];
        const KICK_I_CCW = [
          [
            [0, 0],
            [-1, 0],
            [2, 0],
            [-1, 2],
            [2, -1],
          ],
          [
            [0, 0],
            [2, 0],
            [-1, 0],
            [2, 1],
            [-1, -2],
          ],
          [
            [0, 0],
            [1, 0],
            [-2, 0],
            [1, -2],
            [-2, 1],
          ],
          [
            [0, 0],
            [-2, 0],
            [1, 0],
            [-2, -1],
            [1, 2],
          ],
        ];

        const PIECE_NAMES = ["I", "O", "T", "S", "Z", "J", "L"];
        const LINE_SCORES = [0, 100, 300, 500, 800];
        const SOFT_DROP_SCORE = 1;
        const HARD_DROP_SCORE = 2;

        // NES-inspired speed curve (ms per drop). Each level is noticeably faster.
        const LEVEL_SPEEDS = [
          800, // Level 1
          650, // Level 2
          500, // Level 3
          370, // Level 4
          280, // Level 5
          200, // Level 6
          150, // Level 7
          115, // Level 8
          85, // Level 9
          65, // Level 10
          50, // Level 11
          40, // Level 12
          33, // Level 13
          28, // Level 14
          23, // Level 15
          18, // Level 16+  "kill screen"
        ];

        function getSpeed(lvl) {
          const idx = Math.min(lvl - 1, LEVEL_SPEEDS.length - 1);
          return LEVEL_SPEEDS[idx];
        }

        function getLockDelay(lvl) {
          // Gentle lock delay scaling: 500ms at level 1, down to 350ms at level 15+
          return Math.max(350, 500 - (lvl - 1) * 10);
        }

        // ─── DOM ───
        const boardCanvas = document.getElementById("board");
        const ctx = boardCanvas.getContext("2d");
        const nextCanvas = document.getElementById("next-canvas");
        const nctx = nextCanvas.getContext("2d");
        const holdCanvas = document.getElementById("hold-canvas");
        const hctx = holdCanvas.getContext("2d");
        ctx.imageSmoothingEnabled = false;
        nctx.imageSmoothingEnabled = false;
        hctx.imageSmoothingEnabled = false;
        const scoreEl = document.getElementById("score");
        const levelEl = document.getElementById("level");
        const speedEl = document.getElementById("speed-display");
        const linesEl = document.getElementById("lines");
        const startOverlay = document.getElementById("start-overlay");
        const pauseOverlay = document.getElementById("pause-overlay");
        const gameoverOverlay = document.getElementById("gameover-overlay");
        const finalScoreEl = document.getElementById("final-score");
        const finalBestEl = document.getElementById("final-best");
        const newBestEl = document.getElementById("new-best");
        const highScoreEl = document.getElementById("high-score");

        let highScore =
          parseInt(localStorage.getItem("tetris-high-score")) || 0;
        highScoreEl.textContent = highScore;

        // ─── Game state ───
        let board, score, lines, level, gameOver, paused, started;
        let current, currentX, currentY, currentRotation, currentType;
        let nextType, holdType, holdUsed;
        let bag;
        let dropTimer, lastTime;
        let lockDelay, lockTimer, lockMoves;
        let animatingLines;
        let rafId;

        // ─── Helpers ───
        function createBoard() {
          return Array.from({ length: ROWS }, () =>
            new Array(COLS).fill(EMPTY),
          );
        }

        function getShape(type, rot) {
          return SHAPES[type][rot];
        }

        function shuffledBag() {
          const arr = [...PIECE_NAMES];
          for (let i = arr.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
          }
          return arr;
        }

        function nextPiece() {
          if (bag.length === 0) bag = shuffledBag();
          return bag.pop();
        }

        function collides(shape, bx, by) {
          for (let r = 0; r < shape.length; r++) {
            for (let c = 0; c < shape[r].length; c++) {
              if (shape[r][c] !== 0) {
                const nx = bx + c;
                const ny = by + r;
                if (nx < 0 || nx >= COLS || ny >= ROWS) return true;
                if (ny >= 0 && board[ny][nx] !== EMPTY) return true;
              }
            }
          }
          return false;
        }

        function lockPiece() {
          const shape = getShape(currentType, currentRotation);
          for (let r = 0; r < shape.length; r++) {
            for (let c = 0; c < shape[r].length; c++) {
              if (shape[r][c] !== 0) {
                const ny = currentY + r;
                const nx = currentX + c;
                if (ny < 0) {
                  triggerGameOver();
                  return;
                }
                board[ny][nx] = shape[r][c];
              }
            }
          }
          clearLines();
        }

        function clearLines() {
          const full = [];
          for (let r = 0; r < ROWS; r++) {
            if (board[r].every((c) => c !== EMPTY)) full.push(r);
          }
          if (full.length === 0) {
            holdUsed = false;
            spawn();
            return;
          }

          animatingLines = full;

          // Flash then remove, spawn AFTER clearing is done
          setTimeout(() => {
            // Remove lines first (must be descending to keep indices valid)
            full.sort((a, b) => b - a);
            for (const r of full) {
              board.splice(r, 1);
            }
            // Add new lines at the top
            for (let i = 0; i < full.length; i++) {
              board.unshift(new Array(COLS).fill(EMPTY));
            }

            const count = full.length;
            lines += count;
            score += LINE_SCORES[count] * level;
            level = Math.floor(lines / 10) + 1;
            updateUI();
            animatingLines = null;
            holdUsed = false;
            spawn();
          }, 200);
        }

        function spawn() {
          currentType = nextType;
          nextType = nextPiece();
          currentRotation = 0;
          current = getShape(currentType, 0);
          currentX = Math.floor((COLS - current[0].length) / 2);
          currentY = -1;
          lockTimer = 0;
          lockMoves = 0;
          dropTimer = 0;

          if (collides(current, currentX, currentY)) {
            triggerGameOver();
            return;
          }
          drawNext();
          drawHold();
        }

        function triggerGameOver() {
          gameOver = true;
          cancelAnimationFrame(rafId);
          const isNewBest = score > 0 && score >= highScore;
          if (score > highScore) {
            highScore = score;
            highScoreEl.textContent = highScore;
          }
          localStorage.setItem("tetris-high-score", highScore);
          finalScoreEl.textContent = `Score: ${score}`;
          finalBestEl.textContent = `Best: ${highScore}`;
          newBestEl.style.display = isNewBest ? "block" : "none";
          gameoverOverlay.classList.remove("hidden");
          applyMute();
        }

        function ghostY() {
          const shape = getShape(currentType, currentRotation);
          let gy = currentY;
          while (!collides(shape, currentX, gy + 1)) gy++;
          return gy;
        }

        // ─── Movement ───
        function moveLeft() {
          const shape = getShape(currentType, currentRotation);
          if (!collides(shape, currentX - 1, currentY)) {
            currentX--;
            resetLock();
            return true;
          }
          return false;
        }

        function moveRight() {
          const shape = getShape(currentType, currentRotation);
          if (!collides(shape, currentX + 1, currentY)) {
            currentX++;
            resetLock();
            return true;
          }
          return false;
        }

        function moveDown() {
          const shape = getShape(currentType, currentRotation);
          if (!collides(shape, currentX, currentY + 1)) {
            currentY++;
            return true;
          }
          return false;
        }

        function hardDrop() {
          const shape = getShape(currentType, currentRotation);
          let dropped = 0;
          while (!collides(shape, currentX, currentY + 1)) {
            currentY++;
            dropped++;
          }
          score += dropped * HARD_DROP_SCORE;
          updateUI();
          lockPiece();
        }

        function rotate(dir) {
          const newRot = (currentRotation + dir + 4) % 4;
          const shape = getShape(currentType, newRot);

          let kicks;
          if (currentType === "I") {
            kicks =
              dir === 1 ? KICK_I[currentRotation] : KICK_I_CCW[currentRotation];
          } else if (currentType === "O") {
            kicks = [[0, 0]];
          } else {
            kicks =
              dir === 1
                ? KICK_JLSTZ[currentRotation]
                : KICK_JLSTZ_CCW[currentRotation];
          }

          for (const [kx, ky] of kicks) {
            if (!collides(shape, currentX + kx, currentY - ky)) {
              currentX += kx;
              currentY -= ky;
              currentRotation = newRot;
              current = shape;
              resetLock();
              return true;
            }
          }
          return false;
        }

        function holdPiece() {
          if (holdUsed) return;
          holdUsed = true;
          if (holdType === null) {
            holdType = currentType;
            spawn();
          } else {
            const tmp = holdType;
            holdType = currentType;
            currentType = tmp;
            currentRotation = 0;
            current = getShape(currentType, 0);
            currentX = Math.floor((COLS - current[0].length) / 2);
            currentY = -1;
            lockTimer = 0;
            lockMoves = 0;
          }
          drawHold();
        }

        function resetLock() {
          if (lockMoves < 15) {
            lockTimer = 0;
            lockMoves++;
          }
        }

        // ─── Drawing ───
        function drawBlock(context, x, y, colorId, ghost) {
          context.drawImage(
            ghost ? ghostSprites[colorId] : blockSprites[colorId],
            (x * BLOCK) | 0,
            (y * BLOCK) | 0,
          );
        }

        function drawBoard() {
          ctx.drawImage(bgCanvas, 0, 0);

          // Locked pieces
          for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
              if (board[r][c] !== EMPTY) {
                if (animatingLines && animatingLines.includes(r)) {
                  ctx.fillStyle = "#fff";
                  ctx.fillRect(c * BLOCK, r * BLOCK, BLOCK, BLOCK);
                } else {
                  drawBlock(ctx, c, r, board[r][c]);
                }
              }
            }
          }

          if (gameOver || !currentType) return;

          // Ghost + current piece (single pass)
          const gy = ghostY();
          const shape = getShape(currentType, currentRotation);
          for (let r = 0; r < shape.length; r++) {
            const row = shape[r];
            for (let c = 0; c < row.length; c++) {
              if (row[c] !== 0) {
                const gpy = gy + r;
                if (gpy >= 0) drawBlock(ctx, currentX + c, gpy, row[c], true);
                const py = currentY + r;
                if (py >= 0) drawBlock(ctx, currentX + c, py, row[c]);
              }
            }
          }
        }

        function drawPreview(context, canvas, type) {
          context.fillStyle = "#1a1a2e";
          context.fillRect(0, 0, canvas.width, canvas.height);
          if (!type) return;

          const shape = getShape(type, 0);
          const rows = shape.length;
          const cols = shape[0].length;
          const ox = ((canvas.width - cols * PREVIEW_BLOCK) / 2) | 0;
          const oy = ((canvas.height - rows * PREVIEW_BLOCK) / 2) | 0;

          for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
              if (shape[r][c] !== 0) {
                context.drawImage(
                  previewSprites[shape[r][c]],
                  ox + c * PREVIEW_BLOCK,
                  oy + r * PREVIEW_BLOCK,
                );
              }
            }
          }
        }

        function drawNext() {
          drawPreview(nctx, nextCanvas, nextType);
        }

        function drawHold() {
          drawPreview(hctx, holdCanvas, holdType);
        }

        function updateUI() {
          scoreEl.textContent = score;
          levelEl.textContent = level;
          speedEl.textContent = getSpeed(level);
          linesEl.textContent = lines;
          if (score > highScore) {
            highScore = score;
            highScoreEl.textContent = highScore;
          }
        }

        // ─── DAS / Auto-repeat ───
        const DAS_DELAY = 170;
        const DAS_REPEAT = 50;
        let keys = {};
        let dasTimer = {};
        let dasActive = {};

        function startDAS(key, action) {
          if (dasActive[key]) return;
          action();
          dasActive[key] = true;
          dasTimer[key] = setTimeout(() => {
            dasTimer[key] = setInterval(() => {
              if (!paused && !gameOver && started && !animatingLines) action();
            }, DAS_REPEAT);
          }, DAS_DELAY);
        }

        function stopDAS(key) {
          clearTimeout(dasTimer[key]);
          clearInterval(dasTimer[key]);
          dasActive[key] = false;
        }

        // ─── Input ───
        document.addEventListener("keydown", (e) => {
          // Allow mute toggle in any state
          if (e.code === "KeyM") {
            e.preventDefault();
            toggleMute();
            return;
          }

          if (!started) {
            startGame();
            return;
          }

          if (gameOver) {
            if (e.code === "Escape") {
              quitToTitle();
            } else if (e.code !== "KeyP") {
              gameoverOverlay.classList.add("hidden");
              startGame();
            }
            return;
          }

          if (e.code === "KeyP" || e.code === "Escape") {
            togglePause();
            return;
          }

          if (paused) {
            if (e.code === "ArrowUp" || e.code === "KeyW") {
              e.preventDefault();
              pauseMenuIdx =
                (pauseMenuIdx - 1 + pauseMenuBtns.length) %
                pauseMenuBtns.length;
              highlightPauseBtn();
            } else if (e.code === "ArrowDown" || e.code === "KeyS") {
              e.preventDefault();
              pauseMenuIdx = (pauseMenuIdx + 1) % pauseMenuBtns.length;
              highlightPauseBtn();
            } else if (e.code === "Enter") {
              e.preventDefault();
              pauseMenuBtns[pauseMenuIdx].click();
            }
            return;
          }

          if (animatingLines) return;

          switch (e.code) {
            case "ArrowLeft":
            case "KeyA":
              e.preventDefault();
              startDAS("left", moveLeft);
              break;
            case "ArrowRight":
            case "KeyD":
              e.preventDefault();
              startDAS("right", moveRight);
              break;
            case "ArrowDown":
            case "KeyS":
              e.preventDefault();
              if (!keys["down"]) {
                keys["down"] = true;
              }
              break;
            case "ArrowUp":
            case "KeyW":
            case "KeyX":
              e.preventDefault();
              rotate(1);
              break;
            case "KeyZ":
              e.preventDefault();
              rotate(-1);
              break;
            case "Space":
              e.preventDefault();
              hardDrop();
              break;
            case "KeyC":
            case "ShiftLeft":
            case "ShiftRight":
              e.preventDefault();
              holdPiece();
              break;
          }
        });

        document.addEventListener("keyup", (e) => {
          switch (e.code) {
            case "ArrowLeft":
            case "KeyA":
              stopDAS("left");
              break;
            case "ArrowRight":
            case "KeyD":
              stopDAS("right");
              break;
            case "ArrowDown":
            case "KeyS":
              keys["down"] = false;
              break;
          }
        });

        const pauseMenuBtns = [
          document.getElementById("btn-resume"),
          document.getElementById("btn-restart"),
          document.getElementById("btn-quit"),
        ];
        let pauseMenuIdx = 0;

        function highlightPauseBtn() {
          for (let i = 0; i < pauseMenuBtns.length; i++)
            pauseMenuBtns[i].classList.toggle("selected", i === pauseMenuIdx);
        }

        function togglePause() {
          paused = !paused;
          if (paused) {
            pauseMenuIdx = 0;
            highlightPauseBtn();
            pauseOverlay.classList.remove("hidden");
          } else {
            pauseOverlay.classList.add("hidden");
            lastTime = performance.now();
          }
        }

        function resumeGame() {
          if (!paused) return;
          paused = false;
          pauseOverlay.classList.add("hidden");
          lastTime = performance.now();
        }

        function quitToTitle() {
          paused = false;
          gameOver = false;
          started = false;
          cancelAnimationFrame(rafId);
          pauseOverlay.classList.add("hidden");
          gameoverOverlay.classList.add("hidden");
          startOverlay.classList.remove("hidden");
          ctx.drawImage(bgCanvas, 0, 0);
          drawPreview(nctx, nextCanvas, null);
          drawPreview(hctx, holdCanvas, null);
          scoreEl.textContent = "0";
          levelEl.textContent = "1";
          linesEl.textContent = "0";
          applyMute();
        }

        // Pause menu buttons
        document
          .getElementById("btn-resume")
          .addEventListener("click", resumeGame);
        document.getElementById("btn-restart").addEventListener("click", () => {
          pauseOverlay.classList.add("hidden");
          paused = false;
          startGame();
        });
        document
          .getElementById("btn-quit")
          .addEventListener("click", quitToTitle);

        // ─── Game loop ───
        function gameLoop(time) {
          rafId = requestAnimationFrame(gameLoop);

          if (paused || gameOver || animatingLines) {
            lastTime = time;
            drawBoard();
            return;
          }

          const delta = time - lastTime;
          lastTime = time;

          dropTimer += delta;

          // Check if piece is on ground
          const shape = getShape(currentType, currentRotation);
          let onGround = collides(shape, currentX, currentY + 1);

          // Lock delay scaled by level
          const lockDelay = getLockDelay(level);
          if (onGround) {
            lockTimer += delta;
            if (lockTimer >= lockDelay) {
              lockPiece();
              dropTimer = 0;
            }
          } else {
            lockTimer = 0;
          }

          const dropInterval = keys["down"]
            ? Math.min(50, getSpeed(level))
            : getSpeed(level);

          // Cap accumulated time to prevent massive catch-up after frame hitches
          dropTimer = Math.min(dropTimer, dropInterval * ROWS);

          // Gravity catch-up: move multiple rows if needed for consistent drop speed
          while (dropTimer >= dropInterval && !onGround) {
            dropTimer -= dropInterval;
            onGround = collides(shape, currentX, currentY + 1);
            if (onGround) break;

            if (moveDown()) {
              if (keys["down"]) {
                score += SOFT_DROP_SCORE;
                updateUI();
              }
            } else {
              break;
            }
          }

          drawBoard();
        }

        // ─── Init ───
        function startGame() {
          board = createBoard();
          score = 0;
          lines = 0;
          level = 1;
          gameOver = false;
          paused = false;
          started = true;
          holdType = null;
          holdUsed = false;
          bag = shuffledBag();
          nextType = nextPiece();
          dropTimer = 0;
          lockTimer = 0;
          lockMoves = 0;
          animatingLines = null;
          lastTime = performance.now();

          startOverlay.classList.add("hidden");
          gameoverOverlay.classList.add("hidden");
          pauseOverlay.classList.add("hidden");

          applyMute();
          startAudio();
          updateUI();
          spawn();

          cancelAnimationFrame(rafId);
          rafId = requestAnimationFrame(gameLoop);
        }

        // Initial draw
        ctx.drawImage(bgCanvas, 0, 0);
        drawPreview(nctx, nextCanvas, null);
        drawPreview(hctx, holdCanvas, null);
      })();
    </script>
  </body>
</html>
